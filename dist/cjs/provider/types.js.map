{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../src/provider/types.ts"],"names":[],"mappings":"","sourcesContent":["import type { Address } from \"abitype\";\nimport type {\n  Hash,\n  Hex,\n  HttpTransport,\n  RpcTransactionRequest,\n  Transport,\n} from \"viem\";\nimport type { SignTypedDataParameters } from \"viem/accounts\";\nimport type { z } from \"zod\";\nimport type {\n  ISmartContractAccount,\n  SignTypedDataParams,\n} from \"../account/types.js\";\nimport type {\n  PublicErc4337Client,\n  SupportedTransports,\n} from \"../client/types.js\";\nimport type {\n  BatchUserOperationCallData,\n  UserOperationCallData,\n  UserOperationFeeOptions,\n  UserOperationOverrides,\n  UserOperationReceipt,\n  UserOperationRequest,\n  UserOperationResponse,\n  UserOperationStruct,\n} from \"../types.js\";\nimport type { Deferrable } from \"../utils\";\nimport type {\n  SmartAccountProviderOptsSchema,\n  createSmartAccountProviderConfigSchema,\n} from \"./schema.js\";\n\ntype WithRequired<T, K extends keyof T> = Required<Pick<T, K>>;\ntype WithOptional<T, K extends keyof T> = Pick<Partial<T>, K>;\n\nexport type ConnectorData = {\n  chainId?: Hex;\n};\n\nexport interface ProviderEvents {\n  chainChanged(chainId: Hex): void;\n  accountsChanged(accounts: Address[]): void;\n  connect(data: ConnectorData): void;\n  message({ type, data }: { type: string; data?: unknown }): void;\n  disconnect(): void;\n  error(error: Error): void;\n}\n\nexport type SendUserOperationResult = {\n  hash: Hash;\n  request: UserOperationRequest;\n};\n\nexport type AccountMiddlewareFn = (\n  struct: Deferrable<UserOperationStruct>,\n  overrides?: UserOperationOverrides,\n  feeOptions?: UserOperationFeeOptions\n) => Promise<Deferrable<UserOperationStruct>>;\n\nexport type AccountMiddlewareOverrideFn<\n  Req extends keyof UserOperationStruct = never,\n  Opt extends keyof UserOperationStruct = never\n> = (\n  struct: Deferrable<UserOperationStruct>,\n  overrides?: UserOperationOverrides,\n  feeOptions?: UserOperationFeeOptions\n) => Promise<\n  WithRequired<UserOperationStruct, Req> &\n    WithOptional<UserOperationStruct, Opt>\n>;\n\nexport type PaymasterAndDataMiddleware = AccountMiddlewareOverrideFn<\n  \"paymasterAndData\",\n  | \"callGasLimit\"\n  | \"preVerificationGas\"\n  | \"verificationGasLimit\"\n  | \"maxFeePerGas\"\n  | \"maxPriorityFeePerGas\"\n>;\nexport type GasEstimatorMiddleware = AccountMiddlewareOverrideFn<\n  \"callGasLimit\" | \"preVerificationGas\" | \"verificationGasLimit\"\n>;\nexport type FeeDataMiddleware = AccountMiddlewareOverrideFn<\n  \"maxFeePerGas\" | \"maxPriorityFeePerGas\"\n>;\n\nexport type SmartAccountProviderOpts = z.infer<\n  typeof SmartAccountProviderOptsSchema\n>;\n\nexport type SmartAccountProviderConfig<\n  TTransport extends SupportedTransports = Transport\n> = z.infer<\n  ReturnType<typeof createSmartAccountProviderConfigSchema<TTransport>>\n>;\n\n// TODO: this also will need to implement EventEmitteer\nexport interface ISmartAccountProvider<\n  TTransport extends SupportedTransports = Transport\n> {\n  readonly rpcClient:\n    | PublicErc4337Client<TTransport>\n    | PublicErc4337Client<HttpTransport>;\n  readonly dummyPaymasterDataMiddleware: AccountMiddlewareFn;\n  readonly paymasterDataMiddleware: AccountMiddlewareFn;\n  readonly gasEstimator: AccountMiddlewareFn;\n  readonly feeDataGetter: AccountMiddlewareFn;\n  readonly customMiddleware?: AccountMiddlewareFn;\n\n  readonly account?: ISmartContractAccount;\n\n  /**\n   * Sends a user operation using the connected account.\n   * Before executing, sendUserOperation will run the user operation through the middleware pipeline.\n   * The order of the middlewares is:\n   * 1. dummyPaymasterDataMiddleware -- populates a dummy paymaster data to use in estimation (default: \"0x\")\n   * 2. feeDataGetter -- sets maxfeePerGas and maxPriorityFeePerGas\n   * 3. gasEstimator -- calls eth_estimateUserOperationGas\n   * 4. paymasterMiddleware -- used to set paymasterAndData. (default: \"0x\")\n   * 5. customMiddleware -- allows you to override any of the results returned by previous middlewares\n   *\n   * @param data - either {@link UserOperationCallData} or {@link BatchUserOperationCallData}\n   * @param overrides - optional {@link UserOperationOverrides}\n   * @returns - {@link SendUserOperationResult} containing the hash and request\n   */\n  sendUserOperation: (\n    data: UserOperationCallData | BatchUserOperationCallData,\n    overrides?: UserOperationOverrides\n  ) => Promise<SendUserOperationResult>;\n\n  /**\n   * Attempts to drop and replace an existing user operation by increasing fees\n   *\n   * @param data - an existing user operation request returned by `sendUserOperation`\n   * @param overrides - optional {@link UserOperationOverrides}\n   * @returns - {@link SendUserOperationResult} containing the hash and request\n   */\n  dropAndReplaceUserOperation: (\n    data: UserOperationRequest,\n    overrides?: UserOperationOverrides\n  ) => Promise<SendUserOperationResult>;\n\n  /**\n   * Allows you to get the unsigned UserOperation struct with all of the middleware run on it\n   *\n   * @param data - either {@link UserOperationCallData} or {@link BatchUserOperationCallData}\n   * @param overrides - optional {@link UserOperationOverrides}\n   * @returns - {@link UserOperationStruct} resulting from the middleware pipeline\n   */\n  buildUserOperation: (\n    data: UserOperationCallData | BatchUserOperationCallData,\n    overrides?: UserOperationOverrides\n  ) => Promise<UserOperationStruct>;\n\n  /**\n   * Allows you to check whether the UserOperation to be sent is eligible for gas sponsorship or not.\n   *\n   * @param data - either {@link UserOperationCallData} or {@link BatchUserOperationCallData}\n   * @param overrides - optional {@link UserOperationOverrides}\n   * @returns - {@link UserOperationStruct} resulting from the middleware pipeline\n   */\n  checkGasSponsorshipEligibility: (\n    data: UserOperationCallData | BatchUserOperationCallData,\n    overrides?: UserOperationOverrides\n  ) => Promise<boolean>;\n\n  /**\n   * Allows you to get the unsigned UserOperation struct with all of the middleware run on it\n   * converted from a traditional ethereum transaction\n   *\n   * @param data - {@link RpcTransactionRequest} the tx to convert to a UserOperation\n   * @param overrides - optional {@link UserOperationOverrides}\n   * @returns - {@link UserOperationStruct} resulting from the middleware pipeline\n   */\n  buildUserOperationFromTx: (\n    tx: RpcTransactionRequest,\n    overrides?: UserOperationOverrides\n  ) => Promise<UserOperationStruct>;\n\n  /**\n   * This will wait for the user operation to be included in a transaction that's been mined.\n   * The default retry and wait logic is configured on the Provider itself\n   *\n   * @param hash the user operation hash you want to wait for\n   * @returns the tx hash that included this user operation\n   */\n  waitForUserOperationTransaction: (hash: Hash) => Promise<Hash>;\n\n  /**\n   * calls `eth_getUserOperationByHash` and returns the {@link UserOperationResponse}\n   *\n   * @param hash - the hash of the UserOperation to get the receipt for\n   * @returns - {@link UserOperationResponse}\n   */\n  getUserOperationByHash: (hash: Hash) => Promise<UserOperationResponse | null>;\n\n  /**\n   * calls `eth_getUserOperationReceipt` and returns the {@link UserOperationReceipt}\n   *\n   * @param hash - the hash of the UserOperation to get the receipt for\n   * @returns - {@link UserOperationReceipt}\n   */\n  getUserOperationReceipt: (hash: Hash) => Promise<UserOperationReceipt | null>;\n\n  /**\n   * This takes an ethereum transaction and converts it into a UserOperation, sends the UserOperation, and waits\n   * on the receipt of that UserOperation (ie. has it been mined). If you don't want to wait for the UserOperation\n   * to mine, it's recommended to user {@link sendUserOperation} instead.\n   *\n   * @param request - a {@link RpcTransactionRequest} object representing a traditional ethereum transaction\n   * @param overrides - optional {@link UserOperationOverrides}\\\n   * @returns the transaction hash\n   */\n  sendTransaction: (\n    request: RpcTransactionRequest,\n    overrides?: UserOperationOverrides\n  ) => Promise<Hash>;\n\n  /**\n   * This takes a set of  ethereum transactions and converts them into one UserOperation, sends the UserOperation, and waits\n   * on the receipt of that UserOperation (ie. has it been mined). If you don't want to wait for the UserOperation\n   * to mine, it's recommended to user {@link sendUserOperation} instead.\n   *\n   * NOTE: the account you're sending the transactions to MUST support batch transactions.\n   *\n   * @param request - a {@link RpcTransactionRequest} Array representing a traditional ethereum transaction\n   * @param overrides - optional {@link UserOperationOverrides}\\\n   * @returns the transaction hash\n   */\n  sendTransactions: (\n    request: RpcTransactionRequest[],\n    overrides?: UserOperationOverrides\n  ) => Promise<Hash>;\n\n  /**\n   * EIP-1193 compliant request method\n   *\n   * @param args - object containing the method and params to execute\n   * @returns the result of the method call\n   */\n  request(args: { method: string; params?: any[] }): Promise<any>;\n\n  /**\n   * This method returns an ERC-191 compliant signed message\n   *\n   * @param msg - message to be signed\n   * @returns the signed hash for the message passed\n   */\n  signMessage: (msg: string | Uint8Array) => Promise<Hash>;\n\n  /**\n   * This method is used to sign typed data as per ERC-712\n   *\n   * @param params - {@link SignTypedDataParameters}\n   * @returns the signed hash for the typed data passed\n   */\n  signTypedData: (params: SignTypedDataParameters) => Promise<Hash>;\n\n  /**\n   * If the account is not deployed, it will sign the message and then wrap it in 6492 format\n   *\n   * @param msg - the message to sign\n   * @returns ths signature wrapped in 6492 format\n   */\n  signMessageWith6492(msg: string | Uint8Array | Hex): Promise<Hex>;\n\n  /**\n   * If the account is not deployed, it will sign the typed data blob and then wrap it in 6492 format\n   *\n   * @param params - {@link SignTypedDataParameters}\n   * @returns the signed hash for the params passed in wrapped in 6492 format\n   */\n  signTypedDataWith6492(params: SignTypedDataParams): Promise<Hash>;\n\n  // TODO: potentially add methods here for something like viem's walletActions?\n  /**\n   * @returns the address of the connected account\n   */\n  getAddress: () => Promise<Address>;\n\n  /**\n   * @returns the EntryPoint contract address being used for the provider.\n   *\n   * If the provider is connected with a `SmartContractAccount`, the EntryPoint contract of the connected account\n   * is used for the provider.\n   *\n   * If not connected, it fallbacks to the default entry point contract for the chain, unless the optional parameter\n   * `entryPointAddress` was given during the initialization as an override.\n   *\n   * Refer to https://docs.alchemy.com/reference/eth-supportedentrypoints for all the supported entrypoints\n   * when using Alchemy as your RPC provider.\n   */\n  getEntryPointAddress: () => Address;\n\n  /**\n   * @returns boolean flag indicating if the account is connected\n   */\n  isConnected: () => boolean;\n\n  // Middelware Overriders\n  /**\n   * This method allows you to override the default dummy paymaster data middleware and get paymaster\n   * and data middleware. These middleware are often used together. The dummy paymaster data is used in\n   * gas estimation before we actually have paymaster data. Because the paymaster data has an impact on\n   * the gas estimation, it's good to supply dummy paymaster data that is valid for your paymaster contract.\n   * The getPaymasterAndDataMiddleware is used to make an RPC call to the paymaster contract to get the value\n   * for paymasterAndData.\n   *\n   * @param overrides - optional functions for overriding the default paymaster middleware\n   * @returns an update instance of this, which now uses the new middleware\n   */\n  withPaymasterMiddleware: (overrides: {\n    dummyPaymasterDataMiddleware?: PaymasterAndDataMiddleware;\n    paymasterDataMiddleware?: PaymasterAndDataMiddleware;\n  }) => this;\n\n  /**\n   * Overrides the gasEstimator middleware which is used for setting the gasLimit fields on the UserOperation\n   * prior to execution.\n   *\n   * @param override - a function for overriding the default gas estimator middleware\n   * @returns\n   */\n  withGasEstimator: (override: GasEstimatorMiddleware) => this;\n\n  /**\n   * Overrides the feeDataGetter middleware which is used for setting the fee fields on the UserOperation\n   * prior to execution.\n   *\n   * @param override - a function for overriding the default feeDataGetter middleware\n   * @param feeOptions - optional FeeDataFeeOptions to set at the global level of the provider.\n   * @returns\n   */\n  withFeeDataGetter: (override: FeeDataMiddleware) => this;\n\n  /**\n   * Adds a function to the middleware call stack that runs before calling the paymaster middleware.\n   * It can be used to override or add additional functionality.\n   * Like modifying the user operation, making an additional RPC call, or logging data.\n   *\n   * @param override - the UO transform function to run\n   * @returns\n   */\n  withCustomMiddleware: (override: AccountMiddlewareFn) => this;\n\n  /**\n   * Sets the current account to the account returned by the given function. The function parameter\n   * provides the public rpc client that is used by this provider so the account can make RPC calls.\n   *\n   * @param fn - a function that given public rpc client, returns a smart account\n   */\n  connect<TAccount extends ISmartContractAccount>(\n    fn: (\n      provider:\n        | PublicErc4337Client<TTransport>\n        | PublicErc4337Client<HttpTransport>\n    ) => TAccount\n  ): this & { account: TAccount };\n\n  /**\n   * Allows for disconnecting the account from the provider so you can connect the provider to another account instance\n   *\n   * @returns the provider with the account disconnected\n   */\n  disconnect(): this & { account: undefined };\n\n  /**\n   * Allows you to add additional functionality and utility methods to this provider\n   * via a decorator pattern.\n   *\n   * NOTE: this method does not allow you to override existing methods on the provider.\n   *\n   * @example\n   * ```ts\n   * const provider = new SmartAccountProvider(...).extend((provider) => ({\n   *  debugSendUserOperation: (...args) => {\n   *    console.log(\"debugging send useroperation\");\n   *    return provider.sendUserOperation(...args);\n   *  }\n   * }));\n   *\n   * provider.debugSendUserOperation(...);\n   * ```\n   *\n   * @param extendFn -- this function gives you access to the created provider instance and returns an object\n   * with the extension methods\n   * @returns -- the provider with the extension methods added\n   */\n  extend: <R>(extendFn: (self: this) => R) => this & R;\n}\n"]}