{"version":3,"file":"bigint.js","sourceRoot":"","sources":["../../../src/utils/bigint.ts"],"names":[],"mappings":";;;AAQO,MAAM,SAAS,GAAG,CAAC,GAAG,IAAc,EAAU,EAAE;IACrD,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;QAChB,MAAM,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC;KAC7D;IAED,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChD,CAAC,CAAC;AANW,QAAA,SAAS,aAMpB;AAQK,MAAM,SAAS,GAAG,CAAC,GAAG,IAAc,EAAU,EAAE;IACrD,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;QAChB,MAAM,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC;KAC7D;IAED,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChD,CAAC,CAAC;AANW,QAAA,SAAS,aAMpB;AAUK,MAAM,WAAW,GAAG,CACzB,KAAmB,EACnB,KAAsC,EACtC,KAAsC,EACtC,EAAE;IACF,KAAK,GAAG,KAAK,IAAI,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;IAC7C,KAAK,GAAG,KAAK,IAAI,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;IAE7C,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,GAAG,KAAK,EAAE;QACnD,MAAM,IAAI,KAAK,CACb,8BAA8B,KAAK,6BAA6B,KAAK,EAAE,CACxE,CAAC;KACH;IAED,IAAI,GAAG,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;IACxB,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,GAAG,GAAG,EAAE;QAChC,GAAG,GAAG,KAAK,CAAC;KACb;IACD,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,GAAG,GAAG,EAAE;QAChC,GAAG,GAAG,KAAK,CAAC;KACb;IACD,OAAO,GAAG,CAAC;AACb,CAAC,CAAC;AAtBW,QAAA,WAAW,eAsBtB;AAeK,MAAM,aAAa,GAAG,CAAC,IAAkB,EAAE,OAAe,EAAE,EAAE;IACnE,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,GAAG,IAAI,CAAC;AACzC,CAAC,CAAC;AAFW,QAAA,aAAa,iBAExB","sourcesContent":["import type { BigNumberish } from \"../types\";\n\n/**\n * Returns the max bigint in a list of bigints\n *\n * @param args a list of bigints to get the max of\n * @returns the max bigint in the list\n */\nexport const bigIntMax = (...args: bigint[]): bigint => {\n  if (!args.length) {\n    throw new Error(\"bigIntMax requires at least one argument\");\n  }\n\n  return args.reduce((m, c) => (m > c ? m : c));\n};\n\n/**\n * Returns the min bigint in a list of bigints\n *\n * @param args a list of bigints to get the max of\n * @returns the min bigint in the list\n */\nexport const bigIntMin = (...args: bigint[]): bigint => {\n  if (!args.length) {\n    throw new Error(\"bigIntMin requires at least one argument\");\n  }\n\n  return args.reduce((m, c) => (m < c ? m : c));\n};\n\n/**\n * Given a bigint and a min-max range, returns the min-max clamped bigint value\n *\n * @param value a bigint value to clamp\n * @param lower lower bound min max tuple value\n * @param upper upper bound min max tuple value\n * @returns the clamped bigint value per given range\n */\nexport const bigIntClamp = (\n  value: BigNumberish,\n  lower: BigNumberish | null | undefined,\n  upper: BigNumberish | null | undefined\n) => {\n  lower = lower != null ? BigInt(lower) : null;\n  upper = upper != null ? BigInt(upper) : null;\n\n  if (upper != null && lower != null && upper < lower) {\n    throw new Error(\n      `invalid range: upper bound ${upper} is less than lower bound ${lower}`\n    );\n  }\n\n  let ret = BigInt(value);\n  if (lower != null && lower > ret) {\n    ret = lower;\n  }\n  if (upper != null && upper < ret) {\n    ret = upper;\n  }\n  return ret;\n};\n\n/**\n * Useful if you want to increment a bigint by N% or decrement by N%\n *\n * example:\n * ```\n * const tenPercentIncrease = bigIntPercent(100n, 110n);\n * const tenPercentDecrease = bigIntPercent(100n, 90n);\n * ```\n *\n * @param base -- the base bigint that we want to apply a percent to\n * @param percent -- the percent to apply to the base\n * @returns the base multiplied by the percent and divided by 100\n */\nexport const bigIntPercent = (base: BigNumberish, percent: bigint) => {\n  return (BigInt(base) * percent) / 100n;\n};\n"]}